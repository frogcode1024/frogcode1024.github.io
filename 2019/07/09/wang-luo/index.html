
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>基础-网络 - 贾的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="jww,"> 
    <meta name="description" content="二 网络2.1 基础\1. 各层协议的作用，以及 TCP/IP 协议的特点

\1. 五层协议
应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
传输层 ：,"> 
    <meta name="author" content="JWW"> 
    <link rel="alternative" href="atom.xml" title="贾的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
	<script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('请输入密码') !== '{{ page.password }}'){
                alert('密码错误');
                history.back();
            }
        }
    })();
</script>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">贾的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="https://jiagit.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">基础-网络</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">基础-网络</h1>
        <div class="stuff">
            <span>七月 09, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/网络/">网络</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="二-网络"><a href="#二-网络" class="headerlink" title="二 网络"></a>二 网络</h2><h3 id="2-1-基础"><a href="#2-1-基础" class="headerlink" title="2.1 基础"></a>2.1 基础</h3><p>\1. 各层协议的作用，以及 TCP/IP 协议的特点</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image010.png" alt="img"></p>
<p>\1. 五层协议</p>
<p>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p>
<p>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p>
<p>网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</p>
<p>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<p>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
<p>\2. OSI</p>
<p>其中表示层和会话层用途如下：</p>
<p>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
<p>会话层 ：建立及管理会话。</p>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<p>\3. TCP/IP</p>
<p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image012.png" alt="img"></p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image014.jpg" alt="img"></p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image015.jpg" alt="img"></p>
<p>IP协议：IP(Internet protocol),这里的IP不是值得我们通常所说的192.168.1.1.这个IP指的是一种协议，而后面的数字值得是IP地址。IP协议的作用在于把各种数据包准确无误的传递给对方，其中两个重要的条件是IP地址，和MAC地址（Media Access Control Address）。由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的，除去人为因素外不可能重复。举一个现实生活中的例子，IP地址就如同是我们居住小区的地址，而MAC地址就是我们住的那栋楼那个房间那个人。</p>
<p>TCP协议：如果说IP协议是找到对方的详细地址。那么TCP协议就是安全的把东西带给对方。各有分工，互不冲突。</p>
<p>按层次分，TCP属于传输层，提供可靠的字节流服务。什么叫字节流服务呢？这个名字听起来让人不知所以然，下面听下我通俗的解释。所谓的字节流，其实就类似于信息切割。比如你是一个卖自行车的，你要去送货。安装好的自行车，太过庞大，又不稳定，容易损伤。不如直接把自行车拆开来，每个零件上都贴上收货人的姓名。最后送到后按照把属于同一个人的自行车再组装起来，这个拆解、运输、拼装的过程其实就是TCP字节流的过程。</p>
<p>我们看下严谨的学术表达是怎样的：</p>
<p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</p>
<p>\2. 以太网的特点，以及帧结构</p>
<p>以太网是一种星型拓扑结构局域网。</p>
<p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p>
<p>以太网帧格式：</p>
<p>类型 ：标记上层使用的协议；</p>
<p>数据 ：长度在 46-1500 之间，如果太小则需要填充；</p>
<p>FCS ：帧检验序列，使用的是 CRC 检验方法；</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image017.jpg" alt="img">以太网访问特征：</p>
<p> 共享介质信道，公平的保障信道上的工作站均能控制信道发送和接受；</p>
<p> 公平竞争性介质访问方法。</p>
<p>CSMA/CD</p>
<p> 载波侦听多路访问/冲突检测；</p>
<p> 多路访问。</p>
<p>\3. 集线器、交换机、路由器的作用，以及所属的网络层</p>
<p>集线器：</p>
<p>集线器是物理层的共享设备，不能识别MAC地址和IP地址，局域网内数据包在HUB上是以广播的方式传播的，由每一台终端通过验证数据报头的MAC地址来确定是否接收。如果传输过程中发生碰撞，则需要重新发送数据！它的工作模式是半双工的，同一时刻只能有两个端口传送数据，所有端口共享带宽。</p>
<p>路由器：</p>
<p>路由器工作在网络层，负责两个局域网之间按帧传输数据，路由器通过比对路由表将每一帧传到指定的目的地，路由器的工作模式是全双工的。</p>
<p>交换机：</p>
<p>交换机工作在数据链路层，交换机内部会形成一个端口和MAC地址的MAC表，通过数据报的MAC地址将数据发往指定的端口，因此交换机可用于划分数据链路层的的冲突域。</p>
<p><strong>通俗解释</strong></p>
<p>某一天，你到你女友小芳（暂定这个名字吧）就读的学校去找她，那么你的做法是什么呢：</p>
<p>一、集线器的工作方式： 你站到学校中庭，大喊一声“小芳，我来你找你了！” （广播）</p>
<p>如果这个时候正好有别人也在大喊大叫，你就必须等他喊完了再喊。 （排队）</p>
<p>如果你喊的时候不巧碰上另一个人跟你同时喊，那么你和他喊的内容都不能被听见。 （冲突）</p>
<p>你喊的时候，是听不见别人说什么的，只有喊完了才开始竖起耳朵听。 （半双工工作方式、监听） 果然，对面楼里传来了你女友的声音“你去死吧！” （响应）</p>
<p>二、交换机的工作方式： 你女友事先通知了你她的手机号码（Mac地址）。</p>
<p>你拨通了她的手机。 （建立连接）</p>
<p>对她说“我来找你了，因为我想你想得要死，我的甜心，我的宝贝„„”。 （独享信道）</p>
<p>你的女友听得不耐烦，没等你说完就回了一句“肉麻死了”！ （全双工方式）</p>
<p>三、路由器的工作方式： 你事先把你所有女友所在的XX系XX级XX班XX号座位的信息记录在你的粉红色笔记本上（建立路由表）</p>
<p>你找到了小芳的地址（IP地址），并且确定了如何才能找到她的途径 （路由选择） 。</p>
<p>你到学校门房问到了XX系所在的楼，又到XX系问到了XX班的教室，又到XX教室问到了XX号座位的位置„„经过N次询问（N跳），你终于来到了小芳的面前。</p>
<p>\4. IP 数据数据报常见字段的作用</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image019.jpg" alt="img"></p>
<p>IP数据报分为首部和数据部分。</p>
<p>首部中</p>
<p>版本 : 有 4（IPv4）和 6（IPv6）两个值；</p>
<p>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>
<p>总长度 : 包括首部长度和数据部分长度。</p>
<p>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL为 0 时就丢弃数据报。</p>
<p>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
<p>\5. ARP 协议的作用，以及维护 ARP 缓存的过程</p>
<p>ARP 实现由 IP 地址得到 MAC 地址。每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image021.jpg" alt="img"></p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image023.jpg" alt="img"></p>
<p>\6. ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。</p>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。当传送IP数据包发生错误－－比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。它封装在 IP 数据报中，但是不属于高层协议。</p>
<p>Ping是ICMP的一个重要应用，主要用来测试两台主机之间的连通性。Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。前面说到，尽管ping工具也可以进行侦测，但是，因为ip头的限制，ping不能完全的记录下所经过的路由器。所以Traceroute正好就填补了这个缺憾。</p>
<p>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP时间超过差错报告报文；</p>
<p>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</p>
<p>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
<p>\7. UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP</p>
<p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
<p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image025.jpg" alt="img"></p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image027.jpg" alt="img"></p>
<p>这里再详细说一下面向连接和面向无连接的区别：</p>
<p>面向连接举例：两个人之间通过电话进行通信;</p>
<p>面向无连接举例：邮政服务，用户把信函放在邮件中期待邮政处理流程来传递邮政包裹。</p>
<p>显然，不可达代表不可靠。</p>
<p>下面我们来谈谈TCP和UDP中报文的边界问题。在默认的阻塞模式下，TCP无边界，UDP有边界。<br> 对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；<br> 而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的。</p>
<p>\8. 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用</p>
<p>TCP（Transmission Control Protocol，传输控制协议）是 面向连接的协议，也就是说在收发数据之前，必须先和对方建立连接，</p>
<p>一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的 描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数 据。</p>
<p>需要了解的信息：</p>
<p>ACK ：TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p>
<p>seq确认号：其数值等于发送方的发送序号+1(即接收方期望接收的下一个序列号)。</p>
<p>SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1。因此,  SYN置1就表示这是一个连接请求或连接接受报文。</p>
<p>FIN （finis）即完，终结的意思，用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p>
<p>三次握手—-建立TCP连接</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image029.jpg" alt="img"></p>
<p>首先由Client发出请求连接即 SYN=1 ACK=0 , TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x。</p>
<p>然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1, 再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1, ack=y+1.</p>
<p>然后连接建立，为什么要进行三次握手呢（两次确认）。</p>
<p>​     建立三次握手主要是因为A发送了再一次的确认，那么A为什么会再确认一次呢，主要是为了防止已失效的连接请求报文段又突然传送给B，从而产生了错误。</p>
<p>   所谓“已失效的连接请求报文”是这样产生的，正常情况下，A发出连接请求，但是因为连接报文请求丢失而未收到确认，于是A再重传一次连接请求，后来收到了请求，并收到了确认，建立了连接，数据传输完毕后，就释放链接，A共发送了两次连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”，但是还有异常情况下，A发送的请求报文连接段并没有丢失，而是在某个网络节点滞留较长时间，以致延误到请求释放后的某个时间到达B，本来是一个早已失效的报文段，但是B收到了此失效连接请求报文段后，就误以为A又重新发送的连接请求报文段，并发送确认报文段给A，同意建立连接，如果没有三次握手，那么B发送确认后，连接就建立了，而此时A没有发送建立连接的请求报文段，于是不理会B的确认，也不会给B发送数据，而B却一直等待A发送数据，因此B的许多资源就浪费了，采用三次握手的方式就可以防止这种事情发生，例如刚刚，A不理会B，就不会给B发送确认，B收不到A的确认，就知道A不要求建立连接，就不会白白浪费资源。</p>
<p>四次挥手—-连接释放</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image031.jpg" alt="img"></p>
<p>当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。 A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示，并且用 ack = u+1(如图），A收到后回复一个确认信息，并进入 TIME_WAIT状态，等待 2MSL 时间。</p>
<p>为什么要等待呢？</p>
<p>为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）</p>
<p>另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？  就是保活时间到了后，B会发送探测信息， 以决定是否释放连接。</p>
<p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image033.jpg" alt="img"></p>
<p>TIME_WAIT</p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<p>1.确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
<p>2.等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
<p>\9. 可靠传输原理，并设计可靠 UDP 协议</p>
<p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>实现确认机制、重传机制、窗口确认机制。</p>
<p>如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：</p>
<p>  发送：包的分片、包确认、包的重发</p>
<p>​    接收：包的调序、包的序号确认</p>
<p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。</p>
<p>\10.  TCP 拥塞控制的作用，理解具体原理</p>
<p>TCP 流量控制</p>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image035.jpg" alt="img"></p>
<p>\1. 慢开始与拥塞避免</p>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<p>\2. 快重传与快恢复</p>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd =ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd设定为 ssthresh。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image037.jpg" alt="img"></p>
<p>\11. DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image039.jpg" alt="img"></p>
<p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<p>在两种情况下会使用 TCP 进行传输：</p>
<p>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</p>
<p>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</p>
<p>12.Web页面请求过程（非重点）</p>
<p>动态主机配置协议</p>
<p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<p>\1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP</p>
<p>中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继</p>
<p>代理。</p>
<p>\2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客</p>
<p>户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</p>
<p>\3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</p>
<p>\4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image041.jpg" alt="img"></p>
<p>Web 页面请求过程</p>
<p>\1. DHCP 配置主机信息</p>
<p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p>
<p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p>
<p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p>
<p>\2. ARP 解析 MAC 地址</p>
<p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p>
<p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p>
<p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p>
<p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p>
<p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
<p>\3. DNS 解析域名</p>
<p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p>
<p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p>
<p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p>
<p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p>
<p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p>
<p>\4. HTTP 请求页面</p>
<p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p>
<p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p>
<p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p>
<p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p>
<p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>
<h3 id="2-2-Http"><a href="#2-2-Http" class="headerlink" title="2.2 Http"></a>2.2 Http</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写。HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>
<p>HTTP是一个客户端和服务器端请求和应答的标准，主要用于从万维网（即WWW，全称 World Wide Web）服务器传输超文本到本地浏览器之间的请求数据和响应数据的协议。客户端通过使用网页浏览器或者其它的工具发起一个HTTP请求到服务器上指定端口（默认端口为80），服务器在收到请求之后，返回响应内容（文本、图片等）。HTTP协议是基于TCP协议来进行数据传输的。</p>
<p>HTTP协议已经演化出了很多版本，它们中的大部分都是向下兼容的。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。现在大多使用的都是1.1版本。</p>
<p>1.0版本： HTTP 协议非常老的标准，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。正式因为这种特性造成了一些性能上的缺陷。</p>
<p>1.1版本： 克服了HTTP 1.0的缺陷，HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。同时还增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能（如POST请求头字段等）。</p>
<p>2.0版本： 2015年5月作为互联网标准正式发布。主要新增如下特性：多路复用，二进制分帧，首部压缩，服务端推送。</p>
<p>HTTP之URL</p>
<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息URL。以下面这个URL为例，介绍下普通URL的各部分组成： </p>
<p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="noopener">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a> </p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<p>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p>
<p>2.域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用" target="_blank" rel="noopener">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></p>
<p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>
<p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>
<p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
<p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
<p>URI和URL的区别</p>
<p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。 </p>
<p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的 </p>
<p>URI一般由三部组成： </p>
<p>①访问资源的命名机制 </p>
<p>②存放资源的主机名 </p>
<p>③资源自身的名称，由路径表示，着重强调于资源。</p>
<p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>
<p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成： </p>
<p>①协议(或称为服务方式) </p>
<p>②存有该资源的主机IP地址(有时也包括端口号) </p>
<p>③主机资源的具体地址。如目录和文件名等</p>
<p>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:<a href="mailto:java-net@java.sun.com" target="_blank" rel="noopener">java-net@java.sun.com</a>。</p>
<p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个URL都是URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI都是 URN 的示例。</p>
<p>\1. GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存</p>
<p><strong>作用</strong>：GET 用于获取资源，而 POST 用于传输实体主体。</p>
<p><strong>参数</strong>：GET 和 POST 的请求都能使用额外的参数，但是GET的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具</p>
<p>（Fiddler）查看。因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如“中文”会转换为“%E4%B8%AD%E6%96%87”，而空格会转换为 %20 。POST 参数支持标准字符集。</p>
<p><strong>安全</strong>：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<p><strong>幂等性</strong>的定义是：一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。向支付宝发起支付请求，由于网络问题或系统BUG重发，支付宝应该只扣一次钱。很显然，声明幂等的服务认为，外部调用者会存在多次调用的情况，为了防止外部多次调用对系统数据状态的发生多次改变，将服务设计成幂等。</p>
<p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<p>GET /pageX HTTP/1.1</p>
<p>GET /pageX HTTP/1.1</p>
<p>GET /pageX HTTP/1.1</p>
<p>GET /pageX HTTP/1.1</p>
<p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>
<p>POST /add_row HTTP/1.1 -&gt; Adds a 1nd row</p>
<p>POST /add_row HTTP/1.1 -&gt; Adds a 2nd row</p>
<p>POST /add_row HTTP/1.1 -&gt; Adds a 3rd row</p>
<p><strong>可缓存</strong>：如果要对响应进行缓存，需要满足以下条件：</p>
<p>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</p>
<p>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</p>
<p>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</p>
<p>\2. HTTP 状态码</p>
<p>服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image043.jpg" alt="img"></p>
<p>1XX 信息</p>
<p>2XX 成功</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image045.png" alt="img"> 200 OK</p>
<p>3XX 重定向</p>
<p>4XX 客户端错误</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image045.png" alt="img"> 400 Bad Request ：请求报文中存在语法错误。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image045.png" alt="img"> 403 Forbidden ：请求被拒绝。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image046.png" alt="img"> 404 Not Found</p>
<p>5XX 服务器错误</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image046.png" alt="img"> 500 Internal Server Error ：服务器正在执行请求时发生错误。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image047.png" alt="img"> 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<p>\3. 理解服务器与客户端</p>
<p>客户端:Client</p>
<p>服务器端:Server</p>
<p>一般来说，客户端就是我们使用的电脑（包括我们使用的浏览器IE,Firefox）;服务器端就是存放网页与数据库数据的服务器；</p>
<p>动态网页都是在服务器端执行（例如asp、php等程序）成HTML, XHTML，CSS，javascript，flash等，之后下载到客户端由浏览器显示；</p>
<p>提示: javascript是客户端程序，所以使用其编写的显示时间的程序会根据客户端机器的时间变化，而php、asp是服务器端程序，使用其编写的显示时间程序不会根据客户端变化，只会根据服务器端的时间变化。</p>
<p>举几个客户端与服务器端的例子</p>
<p>你上网浏览网页：</p>
<p>浏览器(IE)就是客户端程序，服务器上的网站就是服务器端程序</p>
<p>你使用QQ聊天：</p>
<p>QQ就是客户端程序，腾讯机房放的存储、交换聊天信息的程序就是服务器端程序</p>
<p>玩魔兽世界：</p>
<p>电脑上装的魔兽程序就是客户端程序，你连接的服务器（九城的服务器）就是服务器端程序</p>
<p>很多人在学习编程的时候并不知道客户端和服务端的关系，今天就让我给你用一个打比方的方法为你解说一下客户端和服务端之间的秘密。</p>
<p>​       我在大学喜欢去清蒸餐厅吃饭，因为比较近，那我进来之后找到卖面的姐姐告诉她我要一碗重庆小面，她便会对着后厨大喊一声：“面条一个”，很快她便去后厨为我端上一碗热腾腾的面条，放好调料之后告诉我：“你的面”。他家的面在我们学校还可以，主要是便宜，好吃，量少，对于减肥的我来说再恰当不过了。在这里，卖面的姐姐是服务员，我是客户。</p>
<p>互联网浏览器和网站之间的关系就像是我和餐厅的关系一样。这一关系包含了大量的请求和响应。我的请求是一碗面，厨房的响应是将我的面做好并端给我。</p>
<p>​      举个例子，你正在看一群美女/帅哥的图片，当然我默认你是在网站上浏览的，那么你电脑上的互联网浏览器就是客户端，而运行着靓图的电脑就是服务端。你的浏览器通过互联网将请求发送给靓图的服务器，服务器接着就会把对应的页面作为响应发给你。接下来，你的浏览器就会将页面在屏幕上渲染出来。</p>
<p>​      在这一关系中，我们称图片返回的即将被浏览器处理的响应为客户端代码。在前面提到的例子中，响应就是端给我的面条，而我就餐坐的餐桌就像是网络浏览器，把一碗面条放在餐桌上，我就可以享用了。</p>
<p>​       我们将页面响应传递过来之前所发生的事情（主要是页面的创建）成为服务端代码（java就是服务端语言）。清蒸餐厅的例子中，服务端代码就是厨房中发生的事情。我不会到厨房去，也看不到他们把饭做出来都经历了什么过程。</p>
<p>​       请记住</p>
<p>​        厨房就像是服务器，服务员就像是互联网。</p>
<p>​        网站是不会把它在“厨房”中做的事情公开的。网站可能使用PHP、ASP.NET或其他编程语言。无论“厨房”里发生什么，对我的浏览器都不会产生影响，只要它交付正确的客户端代码即可。</p>
<p>​        我们在客户端收到的响应其实就是HTML、CSS和JavaScript代码（用火狐浏览器，F12，即可打开开发者工具查看一切客户端代码）</p>
<p>​        客户端就是发生在用户浏览器中的一切（以本例为例，其实客户端范围较,app也属于客户端），而服务端则是发生在运行网站的服务器中的一切。</p>
<p>​       当我们提起客户端代码时，通常指的都是HTML、CSS、JavaScript。当我们提到服务端代码时，常常指的都是一些服务端语言，如：ASP.NET、Ruby on Rails 或 Java。</p>
<p>提示: 客户端程序和服务器端程序通常是多对一关系，即一个服务器端程序，为众多的客户端程序提供数据服务。</p>
<p>提示: 我们在自己的电脑上做网站，调试网站，通常使我们的电脑即充当客户端又充当服务器端。</p>
<p>\4. Cookie 作用、安全性问题、和 Session 的比较</p>
<p>HTTP无状态协议，是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>客户端与服务器进行动态交互的Web应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</p>
<p>作用：</p>
<p>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</p>
<p>个性化设置（如用户自定义设置、主题等）</p>
<p>浏览器行为跟踪（如跟踪分析用户行为等）</p>
<p>cookie分为二种</p>
<p>1，以文件方式存在硬盘空间上的长期性的cookie</p>
<p>2，停留在浏览器所占内存中的临时性的cookie</p>
<p>浏览网站时，你会经常发现网站登录的地方，会有提示，问你是不是要记住自己的登录状态，像这种情况，登录时填写的一些信息会被以文件的方式存放在客户端的硬盘上。</p>
<p>session是一种服务器端的信息管理机制，它把这些文件信息以文件的形势存放在服务器的硬盘空间上。</p>
<p>当客户端向服务器发出请求时，要求服务器端产生一个session时，服务器端会先检查一下，客户端的cookie里面有没有session_id，是否已经过期。如果有这样的session_id的话，服务器端会根据cookie里的session_id把服务器的session检索出来。如果没有这样的session_id的话，服务器端会重新建立一个。</p>
<p>cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
<p>cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。</p>
<p> 简单的说，当你登录一个网站的时候，</p>
<p>如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造，但是如果你能够获取某个登录用户的 sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。</p>
<p>如果浏览器使用的是cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。</p>
<p>Cookie 与 Session 选择</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image047.png" alt="img"> Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image045.png" alt="img"> Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image045.png" alt="img"> 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p>
<p>Cookie 与 Session两个都可以用来存私密的东西，同样也都有有效期的说法，区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。</p>
<p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上</p>
<p>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session</p>
<p>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE</p>
<p>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。</p>
<p>(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p>
<p>\5. 缓存的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理</p>
<p>缓存实现方法：让代理服务器进行缓存；让客户端浏览器进行缓存。</p>
<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p>我们用http访问时，会先发送一个请求，之后服务器返回一个应答，在Chrome的开发者工具(按F12或右击选择检查)中展现了整个过程：</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image050.png" alt="img"></p>
<p>第一部分General是概要，包含请求地址，请求方式，状态码，服务器地址以及Referrer 策略。</p>
<p>第二部分是应答头部，是服务器返回的。</p>
<p>第三部分是请求头部，是客户端发送的。</p>
<p>这次我们从两个角度来看看http的缓存：缓存控制和缓存校验。</p>
<p>缓存控制：控制缓存的开关，用于标识请求或访问中是否开启了缓存，使用了哪种缓存方式。在http中，控制缓存开关的字段有两个：Pragma 和 Cache-Control。</p>
<p>缓存校验：如何校验缓存，比如怎么定义缓存的有效期，怎么确保缓存是最新的。</p>
<p>在缓存中，我们需要一个机制来验证缓存是否有效。比如服务器的资源更新了，客户端需要及时刷新缓存；又或者客户端的资源过了有效期，但服务器上的资源还是旧的，此时并不需要重新发送。缓存校验就是用来解决这些问题的，在http 1.1 中，我们主要关注下Last-Modified 和 etag 这两个字段。</p>
<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）</p>
<p>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。</p>
<p>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</p>
<p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p>
<p>Expires =max-age +   “每次下载时的当前的request时间”，所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 。</p>
<p>在HTTP1.1规范中，新增了一个HTTP头信息：ETag。对Web开发者来说，它是一个非常重要的信息。它是用作缓存使用的两个主要的头信息之一 (另一个是Expires)。</p>
<p>ETag：是实体标签(Entity Tag)的缩写。ETag一般不以明文形式相应给客户端。在资源的各个生命周期中，它都具有不同的值，用于标识出资源的状态。当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化那么ETag也随之发生变化。</p>
<p>ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如</p>
<p><a href="http://www.google.com/" target="_blank" rel="noopener">http://www.google.com/</a> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<p>Eg：ETag: “82e22293907ce725faf67773957acd12”</p>
<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。则</p>
<p>If-None-Match: “82e22293907ce725faf67773957acd12”</p>
<p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。显示结果为</p>
<p>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</p>
<p>If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</p>
<p>\6. 长连接与短连接原理以及使用场景，流水线</p>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>短连接：连接-&gt;传输数据-&gt;关闭连接 </p>
<p>比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。具体就是 浏览器client发起并建立TCP连接 -&gt; client发送HttpRequest报文 -&gt; server接收到报文-&gt;server handle并发送HttpResponse报文给前端,发送完毕之后立即调用socket.close方法-&gt;client接收response报文-&gt;client最终会收到server端断开TCP连接的信号-&gt;client 端断开TCP连接，具体就是调用close方法。也可以这样说：短连接是指SOCKET连接后，发送接收完数据后马上断开连接。因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。</p>
<p>长连接：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ………..-&gt;直到一方关闭连接，多是客户端关闭连接。 </p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</p>
<p>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection: close ；</p>
<p>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive 。</p>
<p>什么时候用长连接，短连接？</p>
<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p>
<p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<p>总之，长连接和短连接的选择要视情况而定。</p>
<p>流水线：默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<p>\7. HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用</p>
<p>HTTP 有以下安全性问题：</p>
<p>使用明文进行通信，内容可能会被窃听；</p>
<p>不验证通信方的身份，通信方的身份有可能遭遇伪装；</p>
<p>无法证明报文的完整性，报文有可能遭篡改。</p>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说HTTPS 使用了隧道进行通信。HTTPS就是安全的HTTP，在http与传输层之间加上了一个SSL对称加密与非对称加密。HTTPS = HTTP+ 加密 + 认证 + 完整性保护。</p>
<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image052.jpg" alt="img"></p>
<p><strong>加密</strong></p>
<p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<p>优点：运算速度快；</p>
<p>缺点：无法安全地将密钥传输给通信方。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image054.jpg" alt="img"></p>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<p>优点：可以更安全地将公开密钥传输给通信发送方；</p>
<p>缺点：运算速度慢。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image056.jpg" alt="img"></p>
<p><strong>认证</strong></p>
<p>通过使用 证书 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image058.jpg" alt="img"></p>
<p><strong>完整性保护</strong></p>
<p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<p>\8. HTTP/1.x 的缺陷，以及 HTTP/2 的特点</p>
<p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>
<p>客户端需要使用多个连接才能实现并发和缩短延迟；</p>
<p>不会压缩请求和响应首部，从而导致不必要的网络流量；</p>
<p>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</p>
<p>HTTP 2.0带来哪些新特性：</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"> 增加二进制分帧</p>
<p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。HTTP 2.0会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中HTTP 1.1的首部信息会被封装到Headers帧，而request body被封装到图中所示的DATA帧。相当于把部分数据塞进了二进制分帧层里，改进传输性能。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"> 压缩头部</p>
<p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"> 服务端推送</p>
<p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>
<p>\9. HTTP/1.1 的特性</p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>默认是长连接</strong></p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求。</p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>支持流水线</strong></p>
<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。</p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>支持同时打开多个 TCP</strong> <strong>连接</strong></p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>支持虚拟主机</strong></p>
<p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>新增状态码 100</strong></p>
<p>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>支持分块传输编码</strong></p>
<p>可以将一个大数据，分段传输，客户端可以慢慢显示。（可以把数据分割成多块，让浏览器逐步显示页面）</p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>新增缓存处理指令 max-age</strong></p>
<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<p>\10. HTTP 与 FTP 的比较</p>
<p>FTP：File Transfer Protocol，文件传输协议。FTP 使用 TCP 进行连接。</p>
<p>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</p>
<p>数据连接：用来传送一个文件数据。</p>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<p>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于1024，因为 0~1023 是熟知端口号。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image063.jpg" alt="img"></p>
<p>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image065.jpg" alt="img"></p>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<p>\1. 同： </p>
<p><strong>（1**</strong>）都是应用层协议；** </p>
<p><strong>（2**</strong>）都运行在TCP<strong><strong>上，即都使用TCP</strong></strong>（而不是UDP<strong>**）作为其支撑的运输层协议。</strong> </p>
<p>\2. 异： </p>
<p><strong>（1**</strong>）HTTP<strong><strong>是超文本传输协议，是面向网页的；FTP</strong></strong>是文件传输协议，是面向文件的。** </p>
<p><strong>（2**</strong>）HTTP<strong><strong>协议默认端口：80</strong></strong>号端口。FTP<strong><strong>协议默认端口：21</strong></strong>号端口。** </p>
<p><strong>（3**</strong>）FTP<strong><strong>的控制信息是带外（out-of-band</strong></strong>）传送的，而HTTP<strong><strong>的控制信息是带内（in-band</strong></strong>）传送的。** </p>
<p>FTP使用两个并行的TCP连接来传输文件，一个是控制连接（control connection），一个是数据连接（data connection）。 控制连接用于在两个主机之间传输控制信息，如用户标识、口令、改变远程目录的命令以及“put”和“get”文件的命令。 数据连接用于实际传输一个文件。 </p>
<p>因为FTP协议使用一个<strong>分离的控制连接</strong>，因此称FTP的控制信息是<strong>带外</strong>传送的。 </p>
<p>而HTTP协议是在传输文件的TCP连接中发送请求和响应<strong>首部行</strong>的，因此其控制信息是带内传送的。 </p>
<p><strong>（4**</strong>）FTP<strong><strong>服务器必须在整个会话期间保留用户的状态（state</strong></strong>）信息，而HTTP<strong>**是无状态的。</strong> </p>
<p>FTP服务器必须把特定的用户账户与控制连接联系起来，随着用户在远程目录树上移动，服务器必须追踪用户在远程目录树上的当前位置。对每个活动着的用户会话的状态进行追踪，可以对FTP会话总数进行限制。 </p>
<p><strong>（5**</strong>）FTP<strong><strong>的控制连接是持久连接，数据连接是非持久连接；而HTTP</strong></strong>既可以使用非持久连接，也可以使用持久连接，默认方式下，HTTP<strong>**使用持久连接。</strong> </p>
<p>当用户主机与远程主机开始一个FTP会话前，FTP的客户机（用户）首先在21号端口上发起一个用于控制的与服务器（远程主机）的TCP连接。FTP的客户机通过该控制连接，发送用户的标识和口令，也发送改变远程目录的命令。 </p>
<p>1）FTP的PORT（主动式）工作方式：当需要传送数据时，<strong>客户端</strong>在<strong>控制</strong>连接链路上用PORT命令告诉<strong>服务器</strong>：“我打开了XXXX端口，你过来连接我”。于是服务器从20端口向客户端的XXXX端口发送连接请求，建立一条<strong>数据连接</strong>链路来传送数据。 </p>
<p>2）FTP的PASV（被动式）工作方式：当需要传送数据时，<strong>服务器</strong>在控制连接链路上用PASV命令告诉<strong>客户端</strong>：“我打开了XXXX端口，你过来连接我”。于是客户端向服务器的XXXX端口发送连接请求，建立一条数据连接链路来传送数据。 </p>
<p>如果在同一个会话期间，用户还需要传输另一个文件，FTP则打开另一个数据连接。 </p>
<p>因此，FTP的控制连接贯穿了整个用户会话期间，但是针对会话中的每一次文件传输，都需要建立一个新的数据连接。故，控制连接是持久连接，而数据连接是非持久连接。</p>
<h3 id="2-3-Socket"><a href="#2-3-Socket" class="headerlink" title="2.3 Socket"></a>2.3 Socket</h3><p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image067.jpg" alt="img"></p>
<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image069.jpg" alt="img"></p>
<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。</p>
<p>上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</p>
<p>\1. 五种 IO 模型的特点以及比较</p>
<p><strong>一个输入操作通常包括两个阶段：</strong></p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>等待数据准备好</strong></p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>从内核向进程复制数据（下图的示例都是右边内核，左边进程）</strong></p>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I/O 模型：</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"> <strong>阻塞式 I/O</strong></p>
<p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率效率会比较高。recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image073.jpg" alt="img"></p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"> <strong>非阻塞式 I/O</strong></p>
<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image075.jpg" alt="img"></p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"> <strong>I/O</strong> <strong>复用（select</strong> <strong>和 poll**</strong>）**</p>
<p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image077.jpg" alt="img"></p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"> <strong>信号驱动式 I/O**</strong>（SIGIO<strong>**）</strong></p>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image079.jpg" alt="img"></p>
<p><strong><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image060.png" alt="img"></strong> <strong>异步 I/O**</strong>（AIO<strong>**）</strong></p>
<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image081.jpg" alt="img"></p>
<p><strong>五大 I/O</strong> <strong>模型比较</strong></p>
<p>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。</p>
<p>异步 I/O：不会阻塞。</p>
<p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p>
<p>\2. select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发</p>
<p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义。</p>
<p><strong>select**</strong>的调用过程如下所示：**</p>
<p><img src="//jiagit.github.io/2019/07/09/wang-luo/clip_image083.jpg" alt="img"></p>
<p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。</p>
<p>比较</p>
<p>\1. 功能</p>
<p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>
<p>select 会修改描述符，而 poll 不会；</p>
<p>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符数量的限制；</p>
<p>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</p>
<p>\2. 速度</p>
<p>select 和 poll 速度都比较慢。</p>
<p>select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。</p>
<p>\3. 可移植性</p>
<p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<p><strong>epoll</strong></p>
<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 仅适用于 Linux OS。</p>
<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和poll 的不确定情况。</p>
<p><strong>应用场景</strong></p>
<p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<p>\1. select 应用场景</p>
<p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。</p>
<p>\2. poll 应用场景</p>
<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<p>\3. epoll 应用场景</p>
<p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在</p>
<p>内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。</p>
<p>工作模式：水平触发LT与边缘触发ET</p>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<p>\1. LT 模式</p>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait()会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<p>\2. ET 模式</p>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>使用脉冲信号来解释LT和ET可能更加贴切。Level是指信号只需要处于水平，就一直会触发；而edge则是指信号为上升沿或者下降沿时触发。说得还有点玄乎，我们以生活中的一个例子来类比LT和ET是如何确定读操作是否就绪的。</p>
<p>水平触发 </p>
<p>儿子：妈妈，我收到了500元的压岁钱。 </p>
<p>妈妈：嗯，省着点花。 </p>
<p>儿子：妈妈，我今天花了200元买了个变形金刚。 </p>
<p>妈妈：以后不要乱花钱。 </p>
<p>儿子：妈妈，我今天买了好多好吃的，还剩下100元。 </p>
<p>妈妈：用完了这些钱，我可不会再给你钱了。 </p>
<p>儿子：妈妈，那100元我没花，我攒起来了 </p>
<p>妈妈：这才是明智的做法！ </p>
<p>儿子：妈妈，那100元我还没花，我还有钱的。 </p>
<p>妈妈：嗯，继续保持。 </p>
<p>儿子：妈妈，我还有100元钱。 </p>
<p>妈妈：…</p>
<p>接下来的情形就是没完没了了：只要儿子一直有钱，他就一直会向他的妈妈汇报。LT模式下，只要内核缓冲区中还有未读数据，就会一直返回描述符的就绪状态，即不断地唤醒应用进程。在上面的例子中，儿子是缓冲区，钱是数据，妈妈则是应用进程了解儿子的压岁钱状况（读操作）。</p>
<p>边缘触发 </p>
<p>儿子：妈妈，我收到了500元的压岁钱。 </p>
<p>妈妈：嗯，省着点花。 </p>
<p>（儿子使用压岁钱购买了变形金刚和零食。） </p>
<p>儿子： </p>
<p>妈妈：儿子你倒是说话啊？压岁钱呢？</p>
<p>这个就是ET模式，儿子只在第一次收到压岁钱时通知妈妈，接下来儿子怎么把压岁钱花掉并没有通知妈妈。即儿子从没钱变成有钱，需要通知妈妈，接下来钱变少了，则不会再通知妈妈了。在ET模式下， 缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="/music/小酒窝.mp3">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="true" data-ci="cd1752eda68aa6866434" data-cs="5f3797db851a87bb206c7b5697c02da9c4eb9d81" data-r="jiagit.github.io" data-o="jiagit" data-a="jiagit" data-d="true">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
